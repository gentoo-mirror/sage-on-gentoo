diff --git a/src/doc/en/thematic_tutorials/explicit_methods_in_number_theory/introduction.rst b/src/doc/en/thematic_tutorials/explicit_methods_in_number_theory/introduction.rst
index 040ffed..840cf6c 100644
--- a/src/doc/en/thematic_tutorials/explicit_methods_in_number_theory/introduction.rst
+++ b/src/doc/en/thematic_tutorials/explicit_methods_in_number_theory/introduction.rst
@@ -71,6 +71,8 @@ positive integer up to :math:`500`.
 
 And, this example draws a similar 3d plot::
 
+    sage: import warnings
+    sage: warnings.simplefilter('ignore', UserWarning)
     sage: v = [[len(factor(n*m)) for n in [1..15]] for m in [1..15]]
     sage: list_plot3d(v, interpolation_type='nn')
     Graphics3d Object
diff --git a/src/sage/plot/arrow.py b/src/sage/plot/arrow.py
index 3eb97eb..ec0f530 100644
--- a/src/sage/plot/arrow.py
+++ b/src/sage/plot/arrow.py
@@ -411,7 +411,7 @@ class Arrow(GraphicPrimitive):
                         return False
 
 
-            class ConditionalStroke(pe._Base):
+            class ConditionalStroke(pe.RendererBase):
 
                 def __init__(self, condition_func, pe_list):
                     """
diff --git a/src/sage/plot/colors.py b/src/sage/plot/colors.py
index b7342b2..6fbc369 100644
--- a/src/sage/plot/colors.py
+++ b/src/sage/plot/colors.py
@@ -20,7 +20,7 @@ comprises the "official" W3C CSS3_ / SVG_ colors.
 For a list of color maps in Sage, evaluate::
 
     sage: sorted(colormaps)
-    ['Accent', 'Accent_r', 'Blues', 'Blues_r', 'BrBG', 'BrBG_r', ...]
+    [u'Accent', u'Accent_r', u'Blues', u'Blues_r', u'BrBG', u'BrBG_r', ...]
 
 These are imported from matplotlib's cm_ module.
 
@@ -1349,7 +1349,7 @@ def get_cmap(cmap):
     and color names.  For a list of map names, evaluate::
 
         sage: sorted(colormaps)
-        ['Accent', 'Accent_r', 'Blues', 'Blues_r', ...]
+        [u'Accent', u'Accent_r', u'Blues', u'Blues_r', ...]
 
     See :func:`rgbcolor` for valid list/tuple element formats.
 
@@ -1410,7 +1410,7 @@ class Colormaps(collections.MutableMapping):
     For a list of map names, evaluate::
 
         sage: sorted(colormaps)
-        ['Accent', 'Accent_r', 'Blues', 'Blues_r', ...]
+        [u'Accent', u'Accent_r', u'Blues', u'Blues_r', ...]
     """
     def __init__(self):
         """
@@ -1657,7 +1657,7 @@ class Colormaps(collections.MutableMapping):
             sage: maps = Colormaps()
             sage: count = len(maps)
             sage: maps.popitem()
-            ('Spectral', <matplotlib.colors.LinearSegmentedColormap object at ...>)
+            (u'Spectral', <matplotlib.colors.LinearSegmentedColormap object at ...>)
             sage: count - 1 == len(maps)
             True
         """
diff --git a/src/sage/plot/graphics.py b/src/sage/plot/graphics.py
index 3750a85..ee86c10 100644
--- a/src/sage/plot/graphics.py
+++ b/src/sage/plot/graphics.py
@@ -2221,7 +2221,7 @@ class Graphics(SageObject):
             sage: subplot = Figure().add_subplot(111)
             sage: p._objects[0]._render_on_subplot(subplot)
             sage: p._matplotlib_tick_formatter(subplot, **d)
-            (<matplotlib.axes.AxesSubplot object at ...>,
+            (<matplotlib.axes._subplots.AxesSubplot object at ...>,
             <matplotlib.ticker.MaxNLocator object at ...>,
             <matplotlib.ticker.MaxNLocator object at ...>,
             <matplotlib.ticker.OldScalarFormatter object at ...>,
diff --git a/src/sage/plot/plot3d/list_plot3d.py b/src/sage/plot/plot3d/list_plot3d.py
index ab47c28..8153bc1 100644
--- a/src/sage/plot/plot3d/list_plot3d.py
+++ b/src/sage/plot/plot3d/list_plot3d.py
@@ -3,16 +3,15 @@ List Plots
 """
 from sage.matrix.matrix import is_Matrix
 from sage.matrix.all import matrix
-from sage.rings.all  import RDF
+from sage.rings.all import RDF
 
-def list_plot3d(v, interpolation_type='default', texture="automatic", point_list=None,**kwds):
+def list_plot3d(v, interpolation_type='default', texture="automatic", point_list=None, **kwds):
     r"""
     A 3-dimensional plot of a surface defined by the list `v`
     of points in 3-dimensional space.
 
     INPUT:
 
-
     - ``v`` - something that defines a set of points in 3
       space, for example:
 
@@ -27,14 +26,16 @@ def list_plot3d(v, interpolation_type='default', texture="automatic", point_list
 
     OPTIONAL KEYWORDS:
 
-    - ``interpolation_type`` - 'linear', 'nn' (nearest neighbor), 'spline'
+    - ``interpolation_type`` - 'linear', 'nn' (natural neighbor), 'spline'
 
       'linear' will perform linear interpolation
 
-      The option 'nn' will interpolate by averaging the value of the
-      nearest neighbors, this produces an interpolating function that is
-      smoother than a linear interpolation, it has one derivative
-      everywhere except at the sample points.
+      The option 'nn' An interpolation method for multivariate data in a 
+      Delaunay triangulation. The value for an interpolation point is 
+      estimated using weighted values of the closest surrounding points in 
+      the triangulation. These points, the natural neighbors, are the ones 
+      the interpolation point would connect to if inserted into the 
+      triangulation.
 
       The option 'spline' interpolates using a bivariate B-spline.
 
@@ -63,7 +64,7 @@ def list_plot3d(v, interpolation_type='default', texture="automatic", point_list
 
     ::
 
-        sage: n = 5; list_plot3d(matrix(RDF,n,[(i+j)%n for i in [1..n] for j in [1..n]]))
+        sage: n = 5; list_plot3d(matrix(RDF, n, [(i+j)%n for i in [1..n] for j in [1..n]]))
         Graphics3d Object
 
     We plot a matrix of values of sin.
@@ -72,7 +73,7 @@ def list_plot3d(v, interpolation_type='default', texture="automatic", point_list
 
         sage: pi = float(pi)
         sage: m = matrix(RDF, 6, [sin(i^2 + j^2) for i in [0,pi/5,..,pi] for j in [0,pi/5,..,pi]])
-        sage: list_plot3d(m, texture='yellow', frame_aspect_ratio=[1,1,1/3])
+        sage: list_plot3d(m, texture='yellow', frame_aspect_ratio=[1, 1, 1/3])
         Graphics3d Object
 
     Though it doesn't change the shape of the graph, increasing
@@ -80,28 +81,30 @@ def list_plot3d(v, interpolation_type='default', texture="automatic", point_list
 
     ::
 
-        sage: list_plot3d(m, texture='yellow', frame_aspect_ratio=[1,1,1/3],num_points=40)
+        sage: list_plot3d(m, texture='yellow', frame_aspect_ratio=[1, 1, 1/3], num_points=40)
         Graphics3d Object
 
     We can change the interpolation type.
 
     ::
 
-        sage: list_plot3d(m, texture='yellow', interpolation_type='nn',frame_aspect_ratio=[1,1,1/3])
+        sage: import warnings
+        sage: warnings.simplefilter('ignore', UserWarning)
+        sage: list_plot3d(m, texture='yellow', interpolation_type='nn', frame_aspect_ratio=[1, 1, 1/3])
         Graphics3d Object
 
     We can make this look better by increasing the number of samples.
 
     ::
 
-        sage: list_plot3d(m, texture='yellow', interpolation_type='nn',frame_aspect_ratio=[1,1,1/3],num_points=40)
+        sage: list_plot3d(m, texture='yellow', interpolation_type='nn', frame_aspect_ratio=[1, 1, 1/3], num_points=40)
         Graphics3d Object
 
     Let's try a spline.
 
     ::
 
-        sage: list_plot3d(m, texture='yellow', interpolation_type='spline',frame_aspect_ratio=[1,1,1/3])
+        sage: list_plot3d(m, texture='yellow', interpolation_type='spline', frame_aspect_ratio=[1, 1, 1/3])
         Graphics3d Object
 
     That spline doesn't capture the oscillation very well; let's try a
@@ -109,7 +112,7 @@ def list_plot3d(v, interpolation_type='default', texture="automatic", point_list
 
     ::
 
-        sage: list_plot3d(m, texture='yellow', interpolation_type='spline', degree=5, frame_aspect_ratio=[1,1,1/3])
+        sage: list_plot3d(m, texture='yellow', interpolation_type='spline', degree=5, frame_aspect_ratio=[1, 1, 1/3])
         Graphics3d Object
 
     We plot a list of lists::
@@ -122,20 +125,20 @@ def list_plot3d(v, interpolation_type='default', texture="automatic", point_list
 
     ::
 
-        sage: l=[]
+        sage: l = []
         sage: for i in range(6):
         ...      for j in range(6):
-        ...         l.append((float(i*pi/5),float(j*pi/5),m[i,j]))
-        sage: list_plot3d(l,texture='yellow')
+        ...         l.append((float(i*pi/5), float(j*pi/5), m[i, j]))
+        sage: list_plot3d(l, texture='yellow')
         Graphics3d Object
 
     Note that the points do not have to be regularly sampled. For example::
 
-        sage: l=[]
-        sage: for i in range(-5,5):
-        ...    for j in range(-5,5):
-        ...      l.append((normalvariate(0,1),normalvariate(0,1),normalvariate(0,1)))
-        sage: list_plot3d(l,interpolation_type='nn',texture='yellow',num_points=100)
+        sage: l = []
+        sage: for i in range(-5, 5):
+        ...    for j in range(-5, 5):
+        ...      l.append((normalvariate(0, 1), normalvariate(0, 1), normalvariate(0, 1)))
+        sage: list_plot3d(l, interpolation_type='nn', texture='yellow', num_points=100)
         Graphics3d Object
 
     TESTS:
@@ -147,12 +150,12 @@ def list_plot3d(v, interpolation_type='default', texture="automatic", point_list
 
     ::
 
-        sage: list_plot3d([(2,3,4)])
+        sage: list_plot3d([(2, 3, 4)])
         Graphics3d Object
 
     ::
 
-        sage: list_plot3d([(0,0,1), (2,3,4)])
+        sage: list_plot3d([(0, 0, 1), (2, 3, 4)])
         Graphics3d Object
 
     However, if two points are given with the same x,y coordinates but
@@ -167,7 +170,7 @@ def list_plot3d(v, interpolation_type='default', texture="automatic", point_list
     Additionally we need at least 3 points to do the interpolation::
 
         sage: mat = matrix(RDF, 1, 2, [3.2, 1.550])
-        sage: show(list_plot3d(mat,interpolation_type='nn'))
+        sage: show(list_plot3d(mat, interpolation_type='nn'))
         Traceback (most recent call last):
         ...
         ValueError: We need at least 3 points to perform the interpolation
@@ -176,17 +179,17 @@ def list_plot3d(v, interpolation_type='default', texture="automatic", point_list
     if texture == "automatic":
         texture = "lightblue"
     if is_Matrix(v):
-        if interpolation_type=='default' or interpolation_type=='linear' and 'num_points' not in kwds:
-            return list_plot3d_matrix(v, texture=texture,  **kwds)
+        if interpolation_type == 'default' or interpolation_type == 'linear' and 'num_points' not in kwds:
+            return list_plot3d_matrix(v, texture=texture, **kwds)
         else:
-            l=[]
+            l = []
             for i in xrange(v.nrows()):
                 for j in xrange(v.ncols()):
-                    l.append((i,j,v[i,j]))
-            return list_plot3d_tuples(l,interpolation_type,texture,**kwds)
+                    l.append((i, j, v[i, j]))
+            return list_plot3d_tuples(l, interpolation_type, texture, **kwds)
 
     if isinstance(v, numpy.ndarray):
-        return list_plot3d(matrix(v),interpolation_type,texture,**kwds)
+        return list_plot3d(matrix(v), interpolation_type, texture, **kwds)
 
     if isinstance(v, list):
         if len(v) == 0:
@@ -201,10 +204,10 @@ def list_plot3d(v, interpolation_type='default', texture="automatic", point_list
             # return a line
             from shapes2 import line3d
             return line3d(v, **kwds)
-        elif isinstance(v[0],tuple) or point_list==True and len(v[0]) == 3:
-            return list_plot3d_tuples(v,interpolation_type,texture=texture, **kwds)
+        elif isinstance(v[0], tuple) or point_list == True and len(v[0]) == 3:
+            return list_plot3d_tuples(v, interpolation_type, texture=texture, **kwds)
         else:
-            return list_plot3d_array_of_arrays(v, interpolation_type,texture, **kwds)
+            return list_plot3d_array_of_arrays(v, interpolation_type, texture, **kwds)
     raise TypeError("v must be a matrix or list")
 
 def list_plot3d_matrix(m, texture, **kwds):
@@ -229,7 +232,7 @@ def list_plot3d_matrix(m, texture, **kwds):
 
     We plot a matrix that illustrates summation modulo `n`::
 
-        sage: n = 5; list_plot3d(matrix(RDF,n,[(i+j)%n for i in [1..n] for j in [1..n]])) # indirect doctest
+        sage: n = 5; list_plot3d(matrix(RDF, n, [(i+j)%n for i in [1..n] for j in [1..n]])) # indirect doctest
         Graphics3d Object
 
     The interpolation type for matrices is 'linear'; for other types
@@ -239,13 +242,13 @@ def list_plot3d_matrix(m, texture, **kwds):
 
         sage: pi = float(pi)
         sage: m = matrix(RDF, 6, [sin(i^2 + j^2) for i in [0,pi/5,..,pi] for j in [0,pi/5,..,pi]])
-        sage: list_plot3d(m, texture='yellow', frame_aspect_ratio=[1,1,1/3]) # indirect doctest
+        sage: list_plot3d(m, texture='yellow', frame_aspect_ratio=[1, 1, 1/3]) # indirect doctest
         Graphics3d Object
         sage: list_plot3d(m, texture='yellow', interpolation_type='linear') # indirect doctest
         Graphics3d Object
     """
     from parametric_surface import ParametricSurface
-    f = lambda i,j: (i,j,float(m[int(i),int(j)]))
+    f = lambda i,j: (i, j, float(m[int(i), int(j)]))
     G = ParametricSurface(f, (range(m.nrows()), range(m.ncols())), texture=texture, **kwds)
     G._set_extra_kwds(kwds)
     return G
@@ -283,14 +286,14 @@ def list_plot3d_array_of_arrays(v, interpolation_type, texture, **kwds):
     With certain extra keywords (see :func:`list_plot3d_matrix`), this function
     will end up using :func:`list_plot3d_tuples`::
 
-        sage: show(list_plot3d([[1, 1, 1, 1], [1, 2, 1, 2], [1, 1, 3, 1], [1, 2, 1, 4]],interpolation_type='spline'))
+        sage: show(list_plot3d([[1, 1, 1, 1], [1, 2, 1, 2], [1, 1, 3, 1], [1, 2, 1, 4]], interpolation_type='spline'))
     """
     m = matrix(RDF, len(v), len(v[0]), v)
-    G = list_plot3d(m,interpolation_type,texture, **kwds)
+    G = list_plot3d(m, interpolation_type, texture, **kwds)
     G._set_extra_kwds(kwds)
     return G
 
-def list_plot3d_tuples(v,interpolation_type, texture, **kwds):
+def list_plot3d_tuples(v, interpolation_type, texture, **kwds):
     r"""
     A 3-dimensional plot of a surface defined by the list `v`
     of points in 3-dimensional space.
@@ -313,14 +316,13 @@ def list_plot3d_tuples(v,interpolation_type, texture, **kwds):
 
     OPTIONAL KEYWORDS:
 
-    - ``interpolation_type`` - 'linear', 'nn' (nearest neighbor), 'spline'
+    - ``interpolation_type`` - 'linear', 'nn' (natural neighbor), 'spline'
 
       'linear' will perform linear interpolation
 
-      The option 'nn' will interpolate by averaging the value of the
-      nearest neighbors, this produces an interpolating function that is
-      smoother than a linear interpolation, it has one derivative
-      everywhere except at the sample points.
+      The option 'nn' will interpolate by using natural neighbors. The 
+      value for an interpolation point is estimated using weighted values 
+      of the closest surrounding points in the triangulation.
 
       The option 'spline' interpolates using a bivariate B-spline.
 
@@ -355,19 +357,19 @@ def list_plot3d_tuples(v,interpolation_type, texture, **kwds):
 
     ::
 
-        sage: list_plot3d(m, texture='yellow', interpolation_type='spline',frame_aspect_ratio=[1,1,1/3])
+        sage: list_plot3d(m, texture='yellow', interpolation_type='spline', frame_aspect_ratio=[1, 1, 1/3])
         Graphics3d Object
 
     ::
 
-        sage: show(list_plot3d([[1, 1, 1], [1, 2, 1], [0, 1, 3], [1, 0, 4]],point_list=True))
+        sage: show(list_plot3d([[1, 1, 1], [1, 2, 1], [0, 1, 3], [1, 0, 4]], point_list=True))
 
     ::
 
-        sage: list_plot3d([(1,2,3),(0,1,3),(2,1,4),(1,0,-2)], texture='yellow', num_points=50)
+        sage: list_plot3d([(1, 2, 3), (0, 1, 3), (2, 1, 4), (1, 0, -2)], texture='yellow', num_points=50)
         Graphics3d Object
     """
-    from matplotlib import delaunay
+    from matplotlib import tri, delaunay
     import numpy
     import scipy
     from random import random
@@ -377,16 +379,16 @@ def list_plot3d_tuples(v,interpolation_type, texture, **kwds):
     if len(v)<3:
         raise ValueError("We need at least 3 points to perform the interpolation")
 
-    x=[float(p[0]) for p in v]
-    y=[float(p[1]) for p in v]
-    z=[float(p[2]) for p in v]
+    x = [float(p[0]) for p in v]
+    y = [float(p[1]) for p in v]
+    z = [float(p[2]) for p in v]
 
     # If the (x,y)-coordinates lie in a one-dimensional subspace, the
     # matplotlib Delaunay code segfaults.  Therefore, we compute the
     # correlation of the x- and y-coordinates and add small random
     # noise to avoid the problem if needed.
-    corr_matrix = numpy.corrcoef(x,y)
-    if corr_matrix[0,1] > 0.9 or corr_matrix[0,1] < -0.9:
+    corr_matrix = numpy.corrcoef(x, y)
+    if corr_matrix[0, 1] > 0.9 or corr_matrix[0, 1] < -0.9:
         ep = float(.000001)
         x = [float(p[0]) + random()*ep for p in v]
         y = [float(p[1]) + random()*ep for p in v]
@@ -399,51 +401,40 @@ def list_plot3d_tuples(v,interpolation_type, texture, **kwds):
     # We also remove duplicate points (which matplotlib can't handle).
     # Alternatively, the code in the if block above which adds random
     # error could be applied to perturb the points.
-    drop_list=[]
-    for i in range(len(x)):
-        for j in range(i+1,len(x)):
-            if x[i]==x[j] and y[i]==y[j]:
-                if z[i]!=z[j]:
+    drop_list = []
+    nb_points = len(x)
+    for i in range(nb_points):
+        for j in range(i+1, nb_points):
+            if x[i] == x[j] and y[i] == y[j]:
+                if z[i] != z[j]:
                     raise ValueError("Two points with same x,y coordinates and different z coordinates were given. Interpolation cannot handle this.")
-                elif z[i]==z[j]:
+                elif z[i] == z[j]:
                     drop_list.append(j)
+    x = [x[i] for i in range(nb_points) if i not in drop_list]
+    y = [y[i] for i in range(nb_points) if i not in drop_list]
+    z = [z[i] for i in range(nb_points) if i not in drop_list]
 
-    x=[x[i] for i in range(len(x)) if i not in drop_list]
-    y=[y[i] for i in range(len(x)) if i not in drop_list]
-    z=[z[i] for i in range(len(x)) if i not in drop_list]
-
-    xmin=float(min(x))
-    xmax=float(max(x))
-    ymin=float(min(y))
-    ymax=float(max(y))
+    xmin = float(min(x))
+    xmax = float(max(x))
+    ymin = float(min(y))
+    ymax = float(max(y))
 
-    num_points= kwds['num_points'] if 'num_points' in kwds else int(4*numpy.sqrt(len(x)))
+    num_points = kwds['num_points'] if 'num_points' in kwds else int(4*numpy.sqrt(len(x)))
                                           #arbitrary choice - assuming more or less a nxn grid of points
                                           # x should have n^2 entries. We sample 4 times that many points.
 
-
-
     if interpolation_type == 'linear':
-
-        T= delaunay.Triangulation(x,y)
-        f=T.linear_interpolator(z)
-        f.default_value=0.0
-        j=numpy.complex(0,1)
-        vals=f[ymin:ymax:j*num_points,xmin:xmax:j*num_points]
+        T = tri.Triangulation(x, y)
+        f = tri.LinearTriInterpolator(T, z)
+        j = numpy.complex(0, 1)
         from parametric_surface import ParametricSurface
-
-        def g(x,y):
-            i=round( (x-xmin)/(xmax-xmin)*(num_points-1) )
-            j=round( (y-ymin)/(ymax-ymin)*(num_points-1) )
-            z=vals[int(j),int(i)]
-            return (x,y,z)
-
-
+        def g(x, y):
+            z = f(x, y)
+            return (x, y, z)
         G = ParametricSurface(g, (list(numpy.r_[xmin:xmax:num_points*j]), list(numpy.r_[ymin:ymax:num_points*j])), texture=texture, **kwds)
         G._set_extra_kwds(kwds)
         return G
 
-
     if interpolation_type == 'nn'  or interpolation_type =='default':
 
         T=delaunay.Triangulation(x,y)
@@ -457,20 +448,19 @@ def list_plot3d_tuples(v,interpolation_type, texture, **kwds):
             j=round( (y-ymin)/(ymax-ymin)*(num_points-1) )
             z=vals[int(j),int(i)]
             return (x,y,z)
-
         G = ParametricSurface(g, (list(numpy.r_[xmin:xmax:num_points*j]), list(numpy.r_[ymin:ymax:num_points*j])), texture=texture, **kwds)
         G._set_extra_kwds(kwds)
         return G
 
-    if interpolation_type =='spline':
+    if interpolation_type == 'spline':
         from plot3d import plot3d
-        kx=kwds['kx'] if 'kx' in kwds else 3
-        ky=kwds['ky'] if 'ky' in kwds else 3
+        kx = kwds['kx'] if 'kx' in kwds else 3
+        ky = kwds['ky'] if 'ky' in kwds else 3
         if 'degree' in kwds:
-            kx=kwds['degree']
-            ky=kwds['degree']
+            kx = kwds['degree']
+            ky = kwds['degree']
+        s = kwds['smoothing'] if 'smoothing' in kwds else len(x)-numpy.sqrt(2*len(x))
+        s = interpolate.bisplrep(x, y, z, [int(1)]*len(x), xmin, xmax, ymin, ymax, kx=kx, ky=ky, s=s)
+        f = lambda x,y: interpolate.bisplev(x, y, s)
+        return plot3d(f, (xmin, xmax), (ymin, ymax), texture=texture, plot_points=[num_points, num_points], **kwds)
 
-        s=kwds['smoothing'] if 'smoothing' in kwds else len(x)-numpy.sqrt(2*len(x))
-        s=interpolate.bisplrep(x,y,z,[int(1)]*len(x),xmin,xmax,ymin,ymax,kx=kx,ky=ky,s=s)
-        f=lambda x,y: interpolate.bisplev(x,y,s)
-        return plot3d(f,(xmin,xmax),(ymin,ymax),texture=texture,plot_points=[num_points,num_points],**kwds)
diff --git a/src/sage/stats/distributions/discrete_gaussian_lattice.py b/src/sage/stats/distributions/discrete_gaussian_lattice.py
index b8fbab0..7a8f1c3 100644
--- a/src/sage/stats/distributions/discrete_gaussian_lattice.py
+++ b/src/sage/stats/distributions/discrete_gaussian_lattice.py
@@ -127,6 +127,8 @@ class DiscreteGaussianDistributionLatticeSampler(SageObject):
     We plot a histogram::
 
         sage: from sage.stats.distributions.discrete_gaussian_lattice import DiscreteGaussianDistributionLatticeSampler
+        sage: import warnings
+        sage: warnings.simplefilter('ignore', UserWarning)
         sage: D = DiscreteGaussianDistributionLatticeSampler(identity_matrix(2), 3.0)
         sage: S = [D() for _ in range(2^12)]
         sage: l = [vector(v.list() + [S.count(v)]) for v in set(S)]
